//
// Generated by Bluespec Compiler, version 2025.01.1-9-g76db531e (build 76db531e)
//
// On Sun Nov  2 15:22:04 UTC 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_start_computation          O     1
// get_result                     O  4096 reg
// RDY_get_result                 O     1
// computation_done               O     1
// RDY_computation_done           O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_computation_a            I  4096 reg
// start_computation_b            I  4096 reg
// start_computation_c            I  4096 reg
// start_computation_d            I  4096 reg
// EN_start_computation           I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBF16_SIMD_Pipeline(CLK,
			    RST_N,

			    start_computation_a,
			    start_computation_b,
			    start_computation_c,
			    start_computation_d,
			    EN_start_computation,
			    RDY_start_computation,

			    get_result,
			    RDY_get_result,

			    computation_done,
			    RDY_computation_done);
  input  CLK;
  input  RST_N;

  // action method start_computation
  input  [4095 : 0] start_computation_a;
  input  [4095 : 0] start_computation_b;
  input  [4095 : 0] start_computation_c;
  input  [4095 : 0] start_computation_d;
  input  EN_start_computation;
  output RDY_start_computation;

  // value method get_result
  output [4095 : 0] get_result;
  output RDY_get_result;

  // value method computation_done
  output computation_done;
  output RDY_computation_done;

  // signals for module outputs
  wire [4095 : 0] get_result;
  wire RDY_computation_done,
       RDY_get_result,
       RDY_start_computation,
       computation_done;

  // register chunk0_a
  reg [1023 : 0] chunk0_a;
  wire [1023 : 0] chunk0_a$D_IN;
  wire chunk0_a$EN;

  // register chunk0_b
  reg [1023 : 0] chunk0_b;
  wire [1023 : 0] chunk0_b$D_IN;
  wire chunk0_b$EN;

  // register chunk0_c
  reg [1023 : 0] chunk0_c;
  wire [1023 : 0] chunk0_c$D_IN;
  wire chunk0_c$EN;

  // register chunk0_d
  reg [1023 : 0] chunk0_d;
  wire [1023 : 0] chunk0_d$D_IN;
  wire chunk0_d$EN;

  // register chunk1_a
  reg [1023 : 0] chunk1_a;
  wire [1023 : 0] chunk1_a$D_IN;
  wire chunk1_a$EN;

  // register chunk1_b
  reg [1023 : 0] chunk1_b;
  wire [1023 : 0] chunk1_b$D_IN;
  wire chunk1_b$EN;

  // register chunk1_c
  reg [1023 : 0] chunk1_c;
  wire [1023 : 0] chunk1_c$D_IN;
  wire chunk1_c$EN;

  // register chunk1_d
  reg [1023 : 0] chunk1_d;
  wire [1023 : 0] chunk1_d$D_IN;
  wire chunk1_d$EN;

  // register chunk2_a
  reg [1023 : 0] chunk2_a;
  wire [1023 : 0] chunk2_a$D_IN;
  wire chunk2_a$EN;

  // register chunk2_b
  reg [1023 : 0] chunk2_b;
  wire [1023 : 0] chunk2_b$D_IN;
  wire chunk2_b$EN;

  // register chunk2_c
  reg [1023 : 0] chunk2_c;
  wire [1023 : 0] chunk2_c$D_IN;
  wire chunk2_c$EN;

  // register chunk2_d
  reg [1023 : 0] chunk2_d;
  wire [1023 : 0] chunk2_d$D_IN;
  wire chunk2_d$EN;

  // register chunk3_a
  reg [1023 : 0] chunk3_a;
  wire [1023 : 0] chunk3_a$D_IN;
  wire chunk3_a$EN;

  // register chunk3_b
  reg [1023 : 0] chunk3_b;
  wire [1023 : 0] chunk3_b$D_IN;
  wire chunk3_b$EN;

  // register chunk3_c
  reg [1023 : 0] chunk3_c;
  wire [1023 : 0] chunk3_c$D_IN;
  wire chunk3_c$EN;

  // register chunk3_d
  reg [1023 : 0] chunk3_d;
  wire [1023 : 0] chunk3_d$D_IN;
  wire chunk3_d$EN;

  // register cycle_count
  reg [31 : 0] cycle_count;
  wire [31 : 0] cycle_count$D_IN;
  wire cycle_count$EN;

  // register result_vector
  reg [4095 : 0] result_vector;
  wire [4095 : 0] result_vector$D_IN;
  wire result_vector$EN;

  // register start_cycle
  reg [31 : 0] start_cycle;
  wire [31 : 0] start_cycle$D_IN;
  wire start_cycle$EN;

  // register state
  reg [1 : 0] state;
  reg [1 : 0] state$D_IN;
  wire state$EN;

  // ports of submodule simd0
  wire [1023 : 0] simd0$get_result,
		  simd0$start_computation_a,
		  simd0$start_computation_b,
		  simd0$start_computation_c,
		  simd0$start_computation_d;
  wire simd0$EN_start_computation,
       simd0$RDY_get_result,
       simd0$RDY_start_computation,
       simd0$computation_done;

  // ports of submodule simd1
  wire [1023 : 0] simd1$get_result,
		  simd1$start_computation_a,
		  simd1$start_computation_b,
		  simd1$start_computation_c,
		  simd1$start_computation_d;
  wire simd1$EN_start_computation,
       simd1$RDY_get_result,
       simd1$RDY_start_computation,
       simd1$computation_done;

  // ports of submodule simd2
  wire [1023 : 0] simd2$get_result,
		  simd2$start_computation_a,
		  simd2$start_computation_b,
		  simd2$start_computation_c,
		  simd2$start_computation_d;
  wire simd2$EN_start_computation,
       simd2$RDY_get_result,
       simd2$RDY_start_computation,
       simd2$computation_done;

  // ports of submodule simd3
  wire [1023 : 0] simd3$get_result,
		  simd3$start_computation_a,
		  simd3$start_computation_b,
		  simd3$start_computation_c,
		  simd3$start_computation_d;
  wire simd3$EN_start_computation,
       simd3$RDY_get_result,
       simd3$RDY_start_computation,
       simd3$computation_done;

  // rule scheduling signals
  wire WILL_FIRE_RL_check_completion, WILL_FIRE_RL_dispatch_parallel;

  // inputs to muxes for submodule ports
  wire MUX_state$write_1__SEL_1;

  // remaining internal signals
  wire simd0_computation_done__8_AND_simd1_computatio_ETC___d44;

  // action method start_computation
  assign RDY_start_computation = state == 2'd0 ;

  // value method get_result
  assign get_result = result_vector ;
  assign RDY_get_result = state == 2'd3 ;

  // value method computation_done
  assign computation_done = state == 2'd3 ;
  assign RDY_computation_done = 1'd1 ;

  // submodule simd0
  mkBF16_SIMD simd0(.CLK(CLK),
		    .RST_N(RST_N),
		    .start_computation_a(simd0$start_computation_a),
		    .start_computation_b(simd0$start_computation_b),
		    .start_computation_c(simd0$start_computation_c),
		    .start_computation_d(simd0$start_computation_d),
		    .EN_start_computation(simd0$EN_start_computation),
		    .RDY_start_computation(simd0$RDY_start_computation),
		    .get_result(simd0$get_result),
		    .RDY_get_result(simd0$RDY_get_result),
		    .computation_done(simd0$computation_done),
		    .RDY_computation_done());

  // submodule simd1
  mkBF16_SIMD simd1(.CLK(CLK),
		    .RST_N(RST_N),
		    .start_computation_a(simd1$start_computation_a),
		    .start_computation_b(simd1$start_computation_b),
		    .start_computation_c(simd1$start_computation_c),
		    .start_computation_d(simd1$start_computation_d),
		    .EN_start_computation(simd1$EN_start_computation),
		    .RDY_start_computation(simd1$RDY_start_computation),
		    .get_result(simd1$get_result),
		    .RDY_get_result(simd1$RDY_get_result),
		    .computation_done(simd1$computation_done),
		    .RDY_computation_done());

  // submodule simd2
  mkBF16_SIMD simd2(.CLK(CLK),
		    .RST_N(RST_N),
		    .start_computation_a(simd2$start_computation_a),
		    .start_computation_b(simd2$start_computation_b),
		    .start_computation_c(simd2$start_computation_c),
		    .start_computation_d(simd2$start_computation_d),
		    .EN_start_computation(simd2$EN_start_computation),
		    .RDY_start_computation(simd2$RDY_start_computation),
		    .get_result(simd2$get_result),
		    .RDY_get_result(simd2$RDY_get_result),
		    .computation_done(simd2$computation_done),
		    .RDY_computation_done());

  // submodule simd3
  mkBF16_SIMD simd3(.CLK(CLK),
		    .RST_N(RST_N),
		    .start_computation_a(simd3$start_computation_a),
		    .start_computation_b(simd3$start_computation_b),
		    .start_computation_c(simd3$start_computation_c),
		    .start_computation_d(simd3$start_computation_d),
		    .EN_start_computation(simd3$EN_start_computation),
		    .RDY_start_computation(simd3$RDY_start_computation),
		    .get_result(simd3$get_result),
		    .RDY_get_result(simd3$RDY_get_result),
		    .computation_done(simd3$computation_done),
		    .RDY_computation_done());

  // rule RL_dispatch_parallel
  assign WILL_FIRE_RL_dispatch_parallel =
	     simd0$RDY_start_computation && simd1$RDY_start_computation &&
	     simd2$RDY_start_computation &&
	     simd3$RDY_start_computation &&
	     state == 2'd1 ;

  // rule RL_check_completion
  assign WILL_FIRE_RL_check_completion =
	     simd0$RDY_get_result && simd1$RDY_get_result &&
	     simd2$RDY_get_result &&
	     simd3$RDY_get_result &&
	     state == 2'd2 ;

  // inputs to muxes for submodule ports
  assign MUX_state$write_1__SEL_1 =
	     WILL_FIRE_RL_check_completion &&
	     simd0_computation_done__8_AND_simd1_computatio_ETC___d44 ;

  // register chunk0_a
  assign chunk0_a$D_IN = start_computation_a[1023:0] ;
  assign chunk0_a$EN = EN_start_computation ;

  // register chunk0_b
  assign chunk0_b$D_IN = start_computation_b[1023:0] ;
  assign chunk0_b$EN = EN_start_computation ;

  // register chunk0_c
  assign chunk0_c$D_IN = start_computation_c[1023:0] ;
  assign chunk0_c$EN = EN_start_computation ;

  // register chunk0_d
  assign chunk0_d$D_IN = start_computation_d[1023:0] ;
  assign chunk0_d$EN = EN_start_computation ;

  // register chunk1_a
  assign chunk1_a$D_IN = start_computation_a[2047:1024] ;
  assign chunk1_a$EN = EN_start_computation ;

  // register chunk1_b
  assign chunk1_b$D_IN = start_computation_b[2047:1024] ;
  assign chunk1_b$EN = EN_start_computation ;

  // register chunk1_c
  assign chunk1_c$D_IN = start_computation_c[2047:1024] ;
  assign chunk1_c$EN = EN_start_computation ;

  // register chunk1_d
  assign chunk1_d$D_IN = start_computation_d[2047:1024] ;
  assign chunk1_d$EN = EN_start_computation ;

  // register chunk2_a
  assign chunk2_a$D_IN = start_computation_a[3071:2048] ;
  assign chunk2_a$EN = EN_start_computation ;

  // register chunk2_b
  assign chunk2_b$D_IN = start_computation_b[3071:2048] ;
  assign chunk2_b$EN = EN_start_computation ;

  // register chunk2_c
  assign chunk2_c$D_IN = start_computation_c[3071:2048] ;
  assign chunk2_c$EN = EN_start_computation ;

  // register chunk2_d
  assign chunk2_d$D_IN = start_computation_d[3071:2048] ;
  assign chunk2_d$EN = EN_start_computation ;

  // register chunk3_a
  assign chunk3_a$D_IN = start_computation_a[4095:3072] ;
  assign chunk3_a$EN = EN_start_computation ;

  // register chunk3_b
  assign chunk3_b$D_IN = start_computation_b[4095:3072] ;
  assign chunk3_b$EN = EN_start_computation ;

  // register chunk3_c
  assign chunk3_c$D_IN = start_computation_c[4095:3072] ;
  assign chunk3_c$EN = EN_start_computation ;

  // register chunk3_d
  assign chunk3_d$D_IN = start_computation_d[4095:3072] ;
  assign chunk3_d$EN = EN_start_computation ;

  // register cycle_count
  assign cycle_count$D_IN = cycle_count + 32'd1 ;
  assign cycle_count$EN = 1'd1 ;

  // register result_vector
  assign result_vector$D_IN =
	     { simd3$get_result,
	       simd2$get_result,
	       simd1$get_result,
	       simd0$get_result } ;
  assign result_vector$EN = MUX_state$write_1__SEL_1 ;

  // register start_cycle
  assign start_cycle$D_IN = cycle_count ;
  assign start_cycle$EN = EN_start_computation ;

  // register state
  always@(MUX_state$write_1__SEL_1 or
	  state or EN_start_computation or WILL_FIRE_RL_dispatch_parallel)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state$write_1__SEL_1: state$D_IN = 2'd3;
      state == 2'd3: state$D_IN = 2'd0;
      EN_start_computation: state$D_IN = 2'd1;
      WILL_FIRE_RL_dispatch_parallel: state$D_IN = 2'd2;
      default: state$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     WILL_FIRE_RL_check_completion &&
	     simd0_computation_done__8_AND_simd1_computatio_ETC___d44 ||
	     state == 2'd3 ||
	     EN_start_computation ||
	     WILL_FIRE_RL_dispatch_parallel ;

  // submodule simd0
  assign simd0$start_computation_a = chunk0_a ;
  assign simd0$start_computation_b = chunk0_b ;
  assign simd0$start_computation_c = chunk0_c ;
  assign simd0$start_computation_d = chunk0_d ;
  assign simd0$EN_start_computation = WILL_FIRE_RL_dispatch_parallel ;

  // submodule simd1
  assign simd1$start_computation_a = chunk1_a ;
  assign simd1$start_computation_b = chunk1_b ;
  assign simd1$start_computation_c = chunk1_c ;
  assign simd1$start_computation_d = chunk1_d ;
  assign simd1$EN_start_computation = WILL_FIRE_RL_dispatch_parallel ;

  // submodule simd2
  assign simd2$start_computation_a = chunk2_a ;
  assign simd2$start_computation_b = chunk2_b ;
  assign simd2$start_computation_c = chunk2_c ;
  assign simd2$start_computation_d = chunk2_d ;
  assign simd2$EN_start_computation = WILL_FIRE_RL_dispatch_parallel ;

  // submodule simd3
  assign simd3$start_computation_a = chunk3_a ;
  assign simd3$start_computation_b = chunk3_b ;
  assign simd3$start_computation_c = chunk3_c ;
  assign simd3$start_computation_d = chunk3_d ;
  assign simd3$EN_start_computation = WILL_FIRE_RL_dispatch_parallel ;

  // remaining internal signals
  assign simd0_computation_done__8_AND_simd1_computatio_ETC___d44 =
	     simd0$computation_done && simd1$computation_done &&
	     simd2$computation_done &&
	     simd3$computation_done ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cycle_count <= `BSV_ASSIGNMENT_DELAY 32'd0;
	start_cycle <= `BSV_ASSIGNMENT_DELAY 32'd0;
	state <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (cycle_count$EN)
	  cycle_count <= `BSV_ASSIGNMENT_DELAY cycle_count$D_IN;
	if (start_cycle$EN)
	  start_cycle <= `BSV_ASSIGNMENT_DELAY start_cycle$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
      end
    if (chunk0_a$EN) chunk0_a <= `BSV_ASSIGNMENT_DELAY chunk0_a$D_IN;
    if (chunk0_b$EN) chunk0_b <= `BSV_ASSIGNMENT_DELAY chunk0_b$D_IN;
    if (chunk0_c$EN) chunk0_c <= `BSV_ASSIGNMENT_DELAY chunk0_c$D_IN;
    if (chunk0_d$EN) chunk0_d <= `BSV_ASSIGNMENT_DELAY chunk0_d$D_IN;
    if (chunk1_a$EN) chunk1_a <= `BSV_ASSIGNMENT_DELAY chunk1_a$D_IN;
    if (chunk1_b$EN) chunk1_b <= `BSV_ASSIGNMENT_DELAY chunk1_b$D_IN;
    if (chunk1_c$EN) chunk1_c <= `BSV_ASSIGNMENT_DELAY chunk1_c$D_IN;
    if (chunk1_d$EN) chunk1_d <= `BSV_ASSIGNMENT_DELAY chunk1_d$D_IN;
    if (chunk2_a$EN) chunk2_a <= `BSV_ASSIGNMENT_DELAY chunk2_a$D_IN;
    if (chunk2_b$EN) chunk2_b <= `BSV_ASSIGNMENT_DELAY chunk2_b$D_IN;
    if (chunk2_c$EN) chunk2_c <= `BSV_ASSIGNMENT_DELAY chunk2_c$D_IN;
    if (chunk2_d$EN) chunk2_d <= `BSV_ASSIGNMENT_DELAY chunk2_d$D_IN;
    if (chunk3_a$EN) chunk3_a <= `BSV_ASSIGNMENT_DELAY chunk3_a$D_IN;
    if (chunk3_b$EN) chunk3_b <= `BSV_ASSIGNMENT_DELAY chunk3_b$D_IN;
    if (chunk3_c$EN) chunk3_c <= `BSV_ASSIGNMENT_DELAY chunk3_c$D_IN;
    if (chunk3_d$EN) chunk3_d <= `BSV_ASSIGNMENT_DELAY chunk3_d$D_IN;
    if (result_vector$EN)
      result_vector <= `BSV_ASSIGNMENT_DELAY result_vector$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    chunk0_a =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk0_b =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk0_c =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk0_d =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk1_a =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk1_b =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk1_c =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk1_d =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk2_a =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk2_b =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk2_c =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk2_d =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk3_a =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk3_b =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk3_c =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    chunk3_d =
	1024'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    cycle_count = 32'hAAAAAAAA;
    result_vector =
	4096'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    start_cycle = 32'hAAAAAAAA;
    state = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_start_computation)
	$display("[Cycle %0d] Starting computation on pipeline module",
		 cycle_count);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_dispatch_parallel)
	$display("[Cycle %0d] All 4 SIMD lanes dispatched in PARALLEL",
		 cycle_count);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_check_completion &&
	  simd0_computation_done__8_AND_simd1_computatio_ETC___d44)
	$display("[Cycle %0d] All SIMD modules completed. Total computation cycles: %0d",
		 cycle_count,
		 cycle_count - start_cycle);
    if (RST_N != `BSV_RESET_VALUE)
      if (state == 2'd3)
	$display("[Cycle %0d] Pipeline auto-reset to Idle (ready for next computation)",
		 cycle_count);
  end
  // synopsys translate_on
endmodule  // mkBF16_SIMD_Pipeline

