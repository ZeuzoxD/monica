//
// Generated by Bluespec Compiler, version 2025.07 (build 282e82e9)
//
// On Fri Nov 14 08:22:20 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_put_data                   O     1 const
// getResult                      O    16 reg
// RDY_getResult                  O     1 reg
// hasResult                      O     1 reg
// RDY_hasResult                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_data_data                  I    16 reg
// EN_put_data                    I     1
// EN_getResult                   I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBF16Sigmoid(CLK,
		     RST_N,

		     put_data_data,
		     EN_put_data,
		     RDY_put_data,

		     EN_getResult,
		     getResult,
		     RDY_getResult,

		     hasResult,
		     RDY_hasResult);
  input  CLK;
  input  RST_N;

  // action method put_data
  input  [15 : 0] put_data_data;
  input  EN_put_data;
  output RDY_put_data;

  // actionvalue method getResult
  input  EN_getResult;
  output [15 : 0] getResult;
  output RDY_getResult;

  // value method hasResult
  output hasResult;
  output RDY_hasResult;

  // signals for module outputs
  wire [15 : 0] getResult;
  wire RDY_getResult, RDY_hasResult, RDY_put_data, hasResult;

  // register result_data
  reg [15 : 0] result_data;
  wire [15 : 0] result_data$D_IN;
  wire result_data$EN;

  // register result_valid
  reg result_valid;
  wire result_valid$D_IN, result_valid$EN;

  // register s1_exp
  reg [7 : 0] s1_exp;
  wire [7 : 0] s1_exp$D_IN;
  wire s1_exp$EN;

  // register s1_man
  reg [6 : 0] s1_man;
  wire [6 : 0] s1_man$D_IN;
  wire s1_man$EN;

  // register s1_sign
  reg s1_sign;
  wire s1_sign$D_IN, s1_sign$EN;

  // register s2_exp
  reg [7 : 0] s2_exp;
  wire [7 : 0] s2_exp$D_IN;
  wire s2_exp$EN;

  // register s2_man
  reg [6 : 0] s2_man;
  wire [6 : 0] s2_man$D_IN;
  wire s2_man$EN;

  // register s2_new_exp
  reg [7 : 0] s2_new_exp;
  wire [7 : 0] s2_new_exp$D_IN;
  wire s2_new_exp$EN;

  // register s2_sign
  reg s2_sign;
  wire s2_sign$D_IN, s2_sign$EN;

  // register s3_new_exp
  reg [7 : 0] s3_new_exp;
  wire [7 : 0] s3_new_exp$D_IN;
  wire s3_new_exp$EN;

  // register s3_new_man
  reg [6 : 0] s3_new_man;
  wire [6 : 0] s3_new_man$D_IN;
  wire s3_new_man$EN;

  // register stage1
  reg [16 : 0] stage1;
  wire [16 : 0] stage1$D_IN;
  wire stage1$EN;

  // register stage2
  reg [16 : 0] stage2;
  wire [16 : 0] stage2$D_IN;
  wire stage2$EN;

  // register stage3
  reg [16 : 0] stage3;
  wire [16 : 0] stage3$D_IN;
  wire stage3$EN;

  // register stage4
  reg [16 : 0] stage4;
  wire [16 : 0] stage4$D_IN;
  wire stage4$EN;

  // remaining internal signals
  reg [7 : 0] IF_s1_exp_4_EQ_129_6_THEN_IF_s1_sign_7_THEN_IF_ETC___d36;
  reg [6 : 0] IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87;
  wire [7 : 0] new_exp__h1055, new_exp__h1082, new_exp__h1085, new_exp__h954;
  wire [6 : 0] new_man__h1327,
	       new_man__h1354,
	       new_man__h1400,
	       new_man__h1446,
	       new_man__h1493,
	       new_man__h1540,
	       new_man__h1586;

  // action method put_data
  assign RDY_put_data = 1'd1 ;

  // actionvalue method getResult
  assign getResult = result_data ;
  assign RDY_getResult = result_valid ;

  // value method hasResult
  assign hasResult = result_valid ;
  assign RDY_hasResult = 1'd1 ;

  // register result_data
  assign result_data$D_IN = { 1'd0, s3_new_exp, s3_new_man } ;
  assign result_data$EN = stage4[0] ;

  // register result_valid
  assign result_valid$D_IN = stage4[0] ;
  assign result_valid$EN = stage4[0] || result_valid ;

  // register s1_exp
  assign s1_exp$D_IN = stage1[15:8] ;
  assign s1_exp$EN = stage1[0] ;

  // register s1_man
  assign s1_man$D_IN = stage1[7:1] ;
  assign s1_man$EN = stage1[0] ;

  // register s1_sign
  assign s1_sign$D_IN = stage1[16] ;
  assign s1_sign$EN = stage1[0] ;

  // register s2_exp
  assign s2_exp$D_IN = s1_exp ;
  assign s2_exp$EN = stage2[0] ;

  // register s2_man
  assign s2_man$D_IN = s1_man ;
  assign s2_man$EN = stage2[0] ;

  // register s2_new_exp
  assign s2_new_exp$D_IN =
	     (s1_exp <= 8'd129) ?
	       IF_s1_exp_4_EQ_129_6_THEN_IF_s1_sign_7_THEN_IF_ETC___d36 :
	       new_exp__h954 ;
  assign s2_new_exp$EN = stage2[0] ;

  // register s2_sign
  assign s2_sign$D_IN = s1_sign ;
  assign s2_sign$EN = stage2[0] ;

  // register s3_new_exp
  assign s3_new_exp$D_IN = s2_new_exp ;
  assign s3_new_exp$EN = stage3[0] ;

  // register s3_new_man
  assign s3_new_man$D_IN =
	     (s2_exp <= 8'd129) ?
	       IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 :
	       7'd0 ;
  assign s3_new_man$EN = stage3[0] ;

  // register stage1
  assign stage1$D_IN = { put_data_data, 1'd1 } ;
  assign stage1$EN = EN_put_data ;

  // register stage2
  assign stage2$D_IN = stage1[0] ? { stage1[16:1], 1'd1 } : 17'd0 ;
  assign stage2$EN = 1'd1 ;

  // register stage3
  assign stage3$D_IN = stage2[0] ? { stage2[16:1], 1'd1 } : 17'd0 ;
  assign stage3$EN = 1'd1 ;

  // register stage4
  assign stage4$D_IN = stage3[0] ? { stage3[16:1], 1'd1 } : 17'd0 ;
  assign stage4$EN = 1'd1 ;

  // remaining internal signals
  assign new_exp__h1055 = s1_sign ? (s1_man[6] ? 8'd122 : 8'd123) : 8'd126 ;
  assign new_exp__h1082 = s1_sign ? 8'd124 : 8'd126 ;
  assign new_exp__h1085 = s1_sign ? 8'd125 : 8'd126 ;
  assign new_exp__h954 = s1_sign ? 8'd0 : 8'd127 ;
  assign new_man__h1327 = s2_sign ? 7'd0 : { 3'h7, s2_man[6:3] } ;
  assign new_man__h1354 = s2_sign ? ~s2_man : { 2'h3, s2_man[6:2] } ;
  assign new_man__h1400 = s2_sign ? ~s2_man : { 1'h1, s2_man[6:1] } ;
  assign new_man__h1446 =
	     s2_sign ? { 1'h0, ~s2_man[6:1] } : { 2'h1, s2_man[6:2] } ;
  assign new_man__h1493 =
	     s2_sign ? { 2'h3, ~s2_man[6:2] } : { 3'h1, s2_man[6:3] } ;
  assign new_man__h1540 =
	     s2_sign ? { 3'h7, ~s2_man[6:3] } : { 4'h1, s2_man[6:4] } ;
  assign new_man__h1586 =
	     s2_sign ? { 4'hF, ~s2_man[6:4] } : { 5'h01, s2_man[6:5] } ;
  always@(s1_exp or
	  new_exp__h1085 or
	  new_exp__h1082 or new_exp__h1055 or s1_sign or s1_man)
  begin
    case (s1_exp)
      8'd127:
	  IF_s1_exp_4_EQ_129_6_THEN_IF_s1_sign_7_THEN_IF_ETC___d36 =
	      new_exp__h1082;
      8'd128:
	  IF_s1_exp_4_EQ_129_6_THEN_IF_s1_sign_7_THEN_IF_ETC___d36 =
	      new_exp__h1055;
      8'd129:
	  IF_s1_exp_4_EQ_129_6_THEN_IF_s1_sign_7_THEN_IF_ETC___d36 =
	      s1_sign ?
		(s1_man[6] ?
		   (s1_man[5] ?
		      (s1_man[4] ? (s1_man[3] ? 8'd0 : 8'd118) : 8'd119) :
		      8'd120) :
		   8'd121) :
		8'd126;
      default: IF_s1_exp_4_EQ_129_6_THEN_IF_s1_sign_7_THEN_IF_ETC___d36 =
		   new_exp__h1085;
    endcase
  end
  always@(s2_exp or
	  new_man__h1586 or
	  new_man__h1540 or
	  new_man__h1493 or
	  new_man__h1446 or
	  new_man__h1400 or new_man__h1354 or new_man__h1327)
  begin
    case (s2_exp)
      8'd124:
	  IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
	      new_man__h1540;
      8'd125:
	  IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
	      new_man__h1493;
      8'd126:
	  IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
	      new_man__h1446;
      8'd127:
	  IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
	      new_man__h1400;
      8'd128:
	  IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
	      new_man__h1354;
      8'd129:
	  IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
	      new_man__h1327;
      default: IF_s2_exp_4_EQ_129_6_THEN_IF_s2_sign_7_THEN_0__ETC___d87 =
		   new_man__h1586;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        result_valid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stage1 <= `BSV_ASSIGNMENT_DELAY 17'd0;
	stage2 <= `BSV_ASSIGNMENT_DELAY 17'd0;
	stage3 <= `BSV_ASSIGNMENT_DELAY 17'd0;
	stage4 <= `BSV_ASSIGNMENT_DELAY 17'd0;
      end
    else
      begin
        if (result_valid$EN)
	  result_valid <= `BSV_ASSIGNMENT_DELAY result_valid$D_IN;
	if (stage1$EN) stage1 <= `BSV_ASSIGNMENT_DELAY stage1$D_IN;
	if (stage2$EN) stage2 <= `BSV_ASSIGNMENT_DELAY stage2$D_IN;
	if (stage3$EN) stage3 <= `BSV_ASSIGNMENT_DELAY stage3$D_IN;
	if (stage4$EN) stage4 <= `BSV_ASSIGNMENT_DELAY stage4$D_IN;
      end
    if (result_data$EN) result_data <= `BSV_ASSIGNMENT_DELAY result_data$D_IN;
    if (s1_exp$EN) s1_exp <= `BSV_ASSIGNMENT_DELAY s1_exp$D_IN;
    if (s1_man$EN) s1_man <= `BSV_ASSIGNMENT_DELAY s1_man$D_IN;
    if (s1_sign$EN) s1_sign <= `BSV_ASSIGNMENT_DELAY s1_sign$D_IN;
    if (s2_exp$EN) s2_exp <= `BSV_ASSIGNMENT_DELAY s2_exp$D_IN;
    if (s2_man$EN) s2_man <= `BSV_ASSIGNMENT_DELAY s2_man$D_IN;
    if (s2_new_exp$EN) s2_new_exp <= `BSV_ASSIGNMENT_DELAY s2_new_exp$D_IN;
    if (s2_sign$EN) s2_sign <= `BSV_ASSIGNMENT_DELAY s2_sign$D_IN;
    if (s3_new_exp$EN) s3_new_exp <= `BSV_ASSIGNMENT_DELAY s3_new_exp$D_IN;
    if (s3_new_man$EN) s3_new_man <= `BSV_ASSIGNMENT_DELAY s3_new_man$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    result_data = 16'hAAAA;
    result_valid = 1'h0;
    s1_exp = 8'hAA;
    s1_man = 7'h2A;
    s1_sign = 1'h0;
    s2_exp = 8'hAA;
    s2_man = 7'h2A;
    s2_new_exp = 8'hAA;
    s2_sign = 1'h0;
    s3_new_exp = 8'hAA;
    s3_new_man = 7'h2A;
    stage1 = 17'h0AAAA;
    stage2 = 17'h0AAAA;
    stage3 = 17'h0AAAA;
    stage4 = 17'h0AAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBF16Sigmoid

